#' Plot a second-order stochastic partial differential equations in multiple space dimension
#'
#' Plots the generated multidimensional SPDE data using the 'plotly' package, generated by [SecondOrderSPDEMulti::simulateSPDEmodelMulti].
#'
#' @param data_list the return of the the SPDE simulation, see [SecondOrderSPDEMulti::simulateSPDEmodelMulti].
#' @param coord_plot a integer in the range of 1 to d, indicating the respective axis to be ploted.
#' @param spatialCoordsRemainingAxes a optional (d-1)-dimensional vector with spatial coordinates on the other axis to be fixed. For instance: 3-dimensions (d=3) and we want to plot the 2. axis, where we fix the 1. axis at 0.3 and the 3. axis at 0.7. Then, 'spatialCoordsRemainingAxes'=c(0.3,0.7). If 'spatialCoordsRemainingAxes'=NA (default), then the mid point on each remaining axis is selected. Note, that the chosen values for the remaining axes have to be on the simulated grid.
#' @param scale a optional parameter indicating the zoom of the camera position.
#' @param cameraPosition an optional 3-dimensional parameter indicating the camera position. See 'plotly' documentation for further information.
#'
#' @return a plotly plot of the generated SPDE model.
#' @seealso [SecondOrderSPDEMulti::simulateSPDEmodelMulti],[SecondOrderSPDEMulti::SecondOrderSPDEMulti]
#' @export
#' @examples
#' d <- 3
#' N <- 50
#' M <- 20
#' theta0 <- 0
#' eta <- 1
#' nu <- c(4,-0.5,0)
#' sigma <- 1
#' alphaDash <- 0.5
#' L <- 10
#'
#' res <- simulateSPDEmodelMulti(d=d,theta0=theta0,nu=nu,eta=eta,sigma=sigma,
#' alphaDash=alphaDash,numberOfSpatialPoints=M,numberOfTemporalPoints=N,L=L)
#'
#' plot_SPDEMulti(data_list = res, coord_plot = 2, spatialCoordsRemainingAxes = c(0.3,0.7))


plot_SPDEMulti <- function(data_list,coord_plot,spatialCoordsRemainingAxes=NA,
                      scale = 1.5,camerPosition = c(1.3,1.3,1.3/2.5)){
  dat <- data_list$data
  SG <- data_list$SG
  t <- data_list$TG
  d <- dim(SG)[2]
  M <- dim(SG)[1]^(1/d)-1
  y <- seq(0,1,1/M)
  N <- length(t)-1
  rgb2 <- function(r,g,b){
    return(rgb(r/255,g/255,b/255))
  }
  darkmint <- c(rgb2(210, 251, 212), rgb2(165, 219, 194),
                rgb2(123, 188, 176), rgb2(85, 156, 158),
                rgb2(58, 124, 137), rgb2(35, 93, 114), rgb2(18, 63, 90))
  reverseColorSheme <- function(colors){
    n <- length(colors)
    return(colors[n:1])
  }
  darkmint2 <- reverseColorSheme(darkmint)
  
  # if(!is.na(spatialCoordsRemainingAxes)){
  #   if(!(spatialCoordsRemainingAxes %in% y)){
  #     stop("'spatialCoordsRemainingAxes' has to be in seq(0,1,1/spatialPoints)!")
  #   }
  # }
  
  
  if (!require("pacman")) {
    install.packages("pacman")
    require(pacman)
  } else {
    require(pacman)
  }
  pacman::p_load(dplyr, pbmcapply,plotly)
  numCores <- detectCores()-1
  
  
  
  
  if(sum(is.na(spatialCoordsRemainingAxes))==1){
    index <- round((M+1)/2)
    spatialCoordsRemainingAxes <- rep(y[index],d-1)
  }
  
  
  l <- lapply(1:length(y), function(i){
    c(y[i],spatialCoordsRemainingAxes)
  })
  SG2 <- do.call(rbind,l)
  
  
  get_perm <- function(select,d){
    a <- 1:d
    for(i in 1:d){
      if(i < select){a[i] = i+1}
      if(i == select){a[i] = 1}
      if(i > select){a[i] = i}
    }
    return(a)
  }
  perm <- get_perm(coord_plot,d)
  SG_comp <- SG2[,perm]
  l <- pbmclapply(1:dim(SG)[1], function(i){
    l2 <- lapply(1:dim(SG_comp)[1], function(j){
      if(isTRUE(all.equal(as.vector(as.matrix(SG[i,])[1,]),SG_comp[j,]))){i}
    })
    unlist(l2)
  },mc.cores = numCores)
  indices <- unique(unlist(l))
  
  dat_plot <- dat[indices,]
  x <- y
  p <- plot_ly(x = ~t, y = ~x, z = ~dat_plot,width = 1000, height = 1000) %>%
    add_surface(contours = list(z = list(
      show=TRUE,
      usecolormap=T,
      project=list(z=TRUE)
    )
    ),
    colorscale = list(seq(0,1,length.out = length(darkmint2)),darkmint2),
    lighting = list(diffuse = 3)) %>%
    layout(scene = list(aspectmode='cube',
                        camera = list(eye = list(x = camerPosition[1]*scale, y = camerPosition[2]*scale, z = camerPosition[3]*scale)),
                        xaxis = list(title = 'Time'),
                        yaxis = list(title = 'Space'),
                        zaxis = list(title = '')
    )
    )%>%
    hide_colorbar()
  return(p)
}



